#+TITLE: SSSP

This will visually demonstrate single-source shortest path graph algorithms.

We will animate Dijkstra's algorithm and run it on a graph that is designed
to show exponential runtime of Dijkstra with negative edges.

TODO: deal with source and target state; ideas:
- make "source" and "target" into graph model attributes
  OR
- make them into private variables and only access them via setters/getters
- remove them as arguments to the graph vis method

Graph API:
clearStatus({sticky: true})
addToPath(edge)
tracePath(target, {addStatus: false, addStickyStatus: false, removeStatus: false, removeStickyStatus: false})
copy()
isWeighted()
makeGraph()

Helper functions defined in app.GraphSimulationView:
initializeDistances: function(graph)
isTense: function(edge) {
relax: function(edge) {
constructPath: function(startNode, edgeTo) {
makeStepAnnotation: function(edge, options) {
makeShortestPathAnnotation: function(curDist) {
makeStepNumberAnnotation: function(num) {
initializeAnnotations: function(annotations) {
runStep: function(i) {
runActions: function(i) {
recordStep: function(graph, annotations) {



[[file:index.py][file:~/Dropbox/code/projects/sssp/index.py]]

[[file:templates/index.html][file:~/Dropbox/code/projects/sssp/templates/index.html]]

[[file:static/application.js][file:~/Dropbox/code/projects/sssp/static/application.js]]
